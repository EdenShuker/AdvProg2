using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using ServerProject.ModelLib;
using Newtonsoft.Json.Linq;
using System;
using ServerProject.ControllerLib.Command;

namespace ServerProject.ControllerLib
{
    /// <summary>
    /// Execute commands sent by clients.
    /// Updates the model and view about changes.
    /// </summary>
    public class Controller : IController
    {
        /// <summary>
        /// Dictionary that maps string, which represents a command, to its command-object.
        /// </summary>
        private Dictionary<string, ICommand> commands;

        /// <summary>
        /// Model of the server.
        /// </summary>
        private IModel model;

        public event EventHandler<ForwardMessageEventArgs> ForwardMessageEvent;

        /// <summary>
        /// Constructor.
        /// </summary>
        public Controller()
        {
            this.model = new Model();
            // Add Commands.
            this.commands = new Dictionary<string, ICommand>();
            this.commands.Add("generate", new GenerateMazeCommand(this.model));
            this.commands.Add("solve", new SolveMazeCommand(this.model));
            this.commands.Add("start", new StartGameCommand(this.model));
            this.commands.Add("list", new ListCommand(this.model));
            this.commands.Add("join", new JoinToGameCommand(this.model));
            this.commands.Add("play", new PlayCommand(this.model));
            this.commands.Add("close", new CloseGameCommand(this.model));
        }

        public void ExecuteCommand(string commandLine, TcpClient client)
        {
            string[] arr = commandLine.Split(' ');
            string commandKey = arr[0];
            // Check if it is existing command
            if (!commands.ContainsKey(commandKey))
            {
                HandleErrorOf(client, "Command not found");
                return;
            }
            // Extract the command from the dictionary.
            ICommand command = commands[commandKey];
            string[] args = arr.Skip(1).ToArray();
            // Check if the arguments, that was given for the command, are valid. 
            Checksum checksum = command.Check(args);
            if (!checksum.Valid)
            {
                HandleErrorOf(client, checksum.ErrorMsg);
                return;
            }
            // Try to execute the command
            try
            {
                ForwardMessageEventArgs eventArgs = command.Execute(args, client);
                // Forward the message, that was generated by the command.
                this.ForwardMessageEvent?.Invoke(this, eventArgs);
            }
            catch (Exception e)
            {
                HandleErrorOf(client, e.Message);
            }
        }

        /// <summary>
        /// Handle an error - send the client an error message.
        /// </summary>
        /// <param name="client">The addressee client.</param>
        /// <param name="errorMsg">The message to send.</param>
        private void HandleErrorOf(TcpClient client, string errorMsg)
        {
            JObject errorObj = new JObject();
            errorObj["Error"] = errorMsg;
            ForwardMessageEventArgs eventArgs = new ForwardMessageEventArgs(client, errorObj.ToString());
            this.ForwardMessageEvent?.Invoke(this, eventArgs);
        }

        public bool ProceedConnectionWith(TcpClient client)
        {
            return model.IsClientInGame(client);
        }
    }
}